name: basic

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

  workflow_dispatch:

  merge_group:

permissions:
  contents: read
  id-token: write # need this for federated login

jobs:
  calculate:
    runs-on: ubuntu-latest
    outputs:
      ###############################
      artifact_result_key: ${{ steps.check_artifacts.outputs.artifact_result_key }}
      ###############################
      # TODO - is there a way to expose these results without having to list each one here?
      artifact_exists_common_src_build: ${{ steps.check_artifacts.outputs.artifact_exists_common_src_build }}
      artifact_fingerprint_common_src_build: ${{ steps.check_artifacts.outputs.artifact_fingerprint_common_src_build }}
      artifact_exists_common_test_test: ${{ steps.check_artifacts.outputs.artifact_exists_common_test_test }}
      artifact_fingerprint_common_test_test: ${{ steps.check_artifacts.outputs.artifact_fingerprint_common_test_test }}
      artifact_exists_src_build: ${{ steps.check_artifacts.outputs.artifact_exists_src_build }}
      artifact_fingerprint_src_build: ${{ steps.check_artifacts.outputs.artifact_fingerprint_src_build }}
      artifact_exists_test_test: ${{ steps.check_artifacts.outputs.artifact_exists_test_test }}
      artifact_fingerprint_test_test: ${{ steps.check_artifacts.outputs.artifact_fingerprint_test_test }}
      #################
      # JSON outputs
      artifact_exists: ${{ steps.check_artifacts.outputs.exists }}
      artifact_fingerprint: ${{ steps.check_artifacts.outputs.fingerprint }}

    steps:
      - uses: actions/checkout@v4
        # if the checkout script/tool is baked into the base runner image, this step can be skipped as it uses the API to get changes
        # NOTE - that _may_ not be true for the merge group event, need to investigate
        with:
          fetch-depth: 0 # fetch all history for all branches and tags

      - name: Load hash cache
        id: load_hash_cache
        uses: actions/cache@v4
        with:
          path: .hashes
          # build hash key with the target branch name, commit SHA, and run ID to generate a unique cache key
          key: hash-cache-${{ github.base_ref }}-${{ github.sha }}-${{ github.run_id }}-${{ github.run_attempt}}
          # use restore keys to restore the cache if the exact key is not found
          # Use keys for
          #  - previous run attempt for this workflow run
          #  - this commit for the target branch
          #  - the target branch. Note that the path filter should ensure that we only use cached hashes that are relevant to the current commit
          restore-keys: |
            hash-cache-${{ github.base_ref }}-${{ github.sha }}-${{ github.run_id }}
            hash-cache-${{ github.base_ref }}-${{ github.sha }}
            hash-cache-${{ github.base_ref }}
        
      - name: run path filter
        id: filter
        # Run through the filters in the specified file.
        # For each filter, evaluate the condition and output to step outputs and GITHUB_ENV
        run: python ./scripts/process_path_filter.py
        env:
          # FILTER_FILE: determines which filter file to process
          FILTER_FILE: ./scripts/filter-example.yaml
          # GITHUB_TOKEN: used to authenticate with the GitHub API to get the list of changed files
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Show filter results
        # note that we don't need to set env vars here as they are set by the process_path_filter.py script
        run: |
          printenv | sort

      - name: Calculate hashes
        id: calculate_hashes
        env:
          FILTER_FILE: ./scripts/filter-example.yaml
        run: |
            python ./scripts/calculate_hashes.py

      # TODO - check out ncc or similar to avoid npm install step: https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action#commit-tag-and-push-your-action
      - name: Check for artifacts - npm install
        run: |
          cd .github/actions/check_artifacts
          npm install
      - name: Azure login with federated credentials
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          allow-no-subscriptions: true
      - name: Check for artifacts
        id: check_artifacts
        uses: ./.github/actions/check_artifacts
        with:
          artifacts-file: ./scripts/example-artifacts.yaml
          storage-account: ${{ vars.AZURE_STORAGE_ACCOUNT }}
          container: artifacts # ensure this exists

      - name: temp
        run: |
          echo "test: ${{ steps.check_artifacts.outputs.test }}"
          echo "===================="
          echo "test.a: ${{ steps.check_artifacts.outputs.test.a }}"
          echo "===================="
          echo 'fingerprint JSON: ${{ steps.check_artifacts.outputs.fingerprint }}'
          echo "===================="
          echo "common_build..."
          echo 'fingerprint: ${{ fromJson(steps.check_artifacts.outputs.fingerprint).common_build }}'
          echo 'fingerprint: ${{ fromJson(steps.check_artifacts.outputs.fingerprint)['common_build'] }}'
          echo 'exists: ${{ fromJson(steps.check_artifacts.outputs.exists).common_build }}'
          echo "===================="
          echo "common_test..."
          echo 'fingerprint: ${{ fromJson(steps.check_artifacts.outputs.fingerprint).common_test }}'
          echo 'exists: ${{ fromJson(steps.check_artifacts.outputs.exists).common_test }}'
          echo "===================="
          echo 'artifact_result_key: ${{ steps.check_artifacts.outputs.artifact_result_key }}'
          echo "===================="
          echo 'artifact_exists_common_build: ${{ steps.check_artifacts.outputs.artifact_exists_common_build }}'
          echo 'artifact_fingerprint_common_build: ${{ steps.check_artifacts.outputs.artifact_fingerprint_common_build }}'
          echo 'artifact_exists_common_test: ${{ steps.check_artifacts.outputs.artifact_exists_common_test }}'
          echo 'artifact_fingerprint_common_test: ${{ steps.check_artifacts.outputs.artifact_fingerprint_common_test }}'
          echo "===================="
          
  build-common:
    runs-on: ubuntu-latest
    needs: calculate
    if:  ${{ !failure() && needs.calculate.outputs.artifact_exists_common_src_build != 'true' }}
    env:
      FINGERPRINT_COMMON_BUILD: ${{ needs.calculate.outputs.artifact_fingerprint_common_src_build }}
    steps:
      - uses: actions/checkout@v4

      - name: Build
        run: |
          echo "Pretending to build... $FINGERPRINT_COMMON_BUILD"
          sleep 5
          echo "common built for $FINGERPRINT_COMMON_BUILD" > build_common.txt
          echo "Pretending to build... done"
          echo '... ${{ needs.calculate.outputs.artifact_exists}}'
          echo '... ${{ fromJson(needs.calculate.outputs.artifact_exists).common_build }}'
      
        # TODO - check out ncc or similar to avoid npm install step: https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action#commit-tag-and-push-your-action
      - name: Upload artifacts - npm install
        run: |
          cd .github/actions/upload_artifacts
          npm install
      - name: Azure login with federated credentials
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          allow-no-subscriptions: true
      - name: upload artifacts
        uses: ./.github/actions/upload_artifacts
        with:
          # azure-client-id: ${{ vars.AZURE_CLIENT_ID }}
          # azure-client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          azure-tenant-id: ${{ vars.AZURE_TENANT_ID }}
          storage-account: ${{ vars.AZURE_STORAGE_ACCOUNT }}
          container: artifacts # ensure this exists
          key: ${{ needs.calculate.outputs.artifact_fingerprint_common_src_build }}
          path: |
            build_common.txt
            README.md

  build:
    runs-on: ubuntu-latest
    needs:
      - calculate
      - build-common
    if:  ${{ (!failure() && needs.calculate.outputs.artifact_exists_src_build != 'true') || success() }}
    env:
      FINGERPRINT_BUILD: ${{ needs.calculate.outputs.artifact_fingerprint_src_build }}
    steps:
      - uses: actions/checkout@v4

      # TODO - check out ncc or similar to avoid npm install step: https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action#commit-tag-and-push-your-action
      - name: Download artifacts - npm install
        run: |
          cd .github/actions/download_artifacts
          npm install
      - name: Azure login with federated credentials
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          allow-no-subscriptions: true
      - name: download artifacts
        uses: ./.github/actions/download_artifacts
        with:
          # azure-client-id: ${{ vars.AZURE_CLIENT_ID }}
          # azure-client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          azure-tenant-id: ${{ vars.AZURE_TENANT_ID }}
          storage-account: ${{ vars.AZURE_STORAGE_ACCOUNT }}
          container: artifacts # ensure this exists
          key: ${{ needs.calculate.outputs.artifact_fingerprint_common_src_build }}
          path: ./common_build_output/

      - name: Build
        run: |
          echo "Pretending to build... $FINGERPRINT_BUILD"
          echo "build_common.txt:"
          cat ./common_build_output/build_common.txt
          echo "===================="
          sleep 5
          echo "common built for $FINGERPRINT_BUILD" > build.txt
          echo "Inputs:" >> build.txt
          cat  ./common_build_output/build_common.txt >> build.txt
          echo "Pretending to build... done"
      
        # TODO - check out ncc or similar to avoid npm install step: https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action#commit-tag-and-push-your-action
      - name: Upload artifacts - npm install
        run: |
          cd .github/actions/upload_artifacts
          npm install
      - name: Azure login with federated credentials
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          allow-no-subscriptions: true
      - name: upload artifacts
        uses: ./.github/actions/upload_artifacts
        with:
          # azure-client-id: ${{ vars.AZURE_CLIENT_ID }}
          # azure-client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          azure-tenant-id: ${{ vars.AZURE_TENANT_ID }}
          storage-account: ${{ vars.AZURE_STORAGE_ACCOUNT }}
          container: artifacts # ensure this exists
          key: ${{ needs.calculate.outputs.artifact_fingerprint_src_build }}
          path: |
            build.txt

  test-common:
    runs-on: ubuntu-latest
    needs:
      - calculate
      - build-common
    if:  ${{ (!failure() && needs.calculate.outputs.artifact_exists_common_test_test != 'true') || success() }}
    env:
      FINGERPRINT_COMMON_TEST: ${{ needs.calculate.outputs.artifact_fingerprint_common_test_test }}
    steps:
      - uses: actions/checkout@v4

      - name: Test
        run: |
          echo "fingerprint_common_build: ${{ needs.calculate.outputs.artifact_fingerprint_common_src_build }}"
          echo "fingerprint_common_test: ${{ needs.calculate.outputs.artifact_fingerprint_common_test_test }}"


      # TODO - check out ncc or similar to avoid npm install step: https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action#commit-tag-and-push-your-action
      - name: Download artifacts - npm install
        run: |
          cd .github/actions/download_artifacts
          npm install
      - name: Azure login with federated credentials
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          allow-no-subscriptions: true
      - name: download artifacts
        uses: ./.github/actions/download_artifacts
        with:
          # azure-client-id: ${{ vars.AZURE_CLIENT_ID }}
          # azure-client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          azure-tenant-id: ${{ vars.AZURE_TENANT_ID }}
          storage-account: ${{ vars.AZURE_STORAGE_ACCOUNT }}
          container: artifacts # ensure this exists
          key: ${{ needs.calculate.outputs.artifact_fingerprint_common_src_build }}
          path: ./common_build_output/
      
      - name: Test
        run: |
          echo "Pretending to test... $FINGERPRINT_COMMON_TEST"
          echo "build_common.txt:"
          cat ./common_build_output/build_common.txt
          echo "===================="
          sleep 5
          echo "common tested for $FINGERPRINT_COMMON_TEST" > test_common.txt
          echo "Inputs:" >> test_common.txt
          cat  ./common_build_output/build_common.txt >> test_common.txt
          echo "Pretending to test... done"


      # TODO - check out ncc or similar to avoid npm install step: https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action#commit-tag-and-push-your-action
      - name: Upload artifacts - npm install
        run: |
          cd .github/actions/upload_artifacts
          npm install
      - name: Azure login with federated credentials
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          allow-no-subscriptions: true
      - name: upload artifacts
        uses: ./.github/actions/upload_artifacts
        with:
          # azure-client-id: ${{ vars.AZURE_CLIENT_ID }}
          # azure-client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          azure-tenant-id: ${{ vars.AZURE_TENANT_ID }}
          storage-account: ${{ vars.AZURE_STORAGE_ACCOUNT }}
          container: artifacts # ensure this exists
          key: ${{ needs.calculate.outputs.artifact_fingerprint_common_test_test }}
          path: |
            test_common.txt

      - name: gather azcopy logs
        if: ${{ failure() }}
        run: |
          mkdir -p azcopy-logs
          cp /home/runner/.azcopy/*.log azcopy-logs/

      - name: Upload azcopy logs
        if: ${{ failure() }}
        uses: actions/upload-artifact@v4
        with:
          name: azcopy-log
          path: |
             /home/runner/.azcopy/
             azcopy-logs/*


  test:
    runs-on: ubuntu-latest
    needs:
      - calculate
      - build-common
      - build
    if:  ${{ (!failure() && needs.calculate.outputs.artifact_exists_test_test != 'true') || success() }}
    env:
      FINGERPRINT_COMMON_TEST: ${{ needs.calculate.outputs.artifact_exists_test_test }}
    steps:
      - uses: actions/checkout@v4

      # TODO - check out ncc or similar to avoid npm install step: https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action#commit-tag-and-push-your-action
      - name: Download artifacts - npm install
        run: |
          cd .github/actions/download_artifacts
          npm install
      - name: Azure login with federated credentials
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          allow-no-subscriptions: true
      - name: download artifacts (common_src_build)
        uses: ./.github/actions/download_artifacts
        with:
          # azure-client-id: ${{ vars.AZURE_CLIENT_ID }}
          # azure-client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          azure-tenant-id: ${{ vars.AZURE_TENANT_ID }}
          storage-account: ${{ vars.AZURE_STORAGE_ACCOUNT }}
          container: artifacts # ensure this exists
          key: ${{ needs.calculate.outputs.artifact_fingerprint_common_src_build }}
          path: ./common_build_output/
      - name: download artifacts (src_build)
        uses: ./.github/actions/download_artifacts
        with:
          # azure-client-id: ${{ vars.AZURE_CLIENT_ID }}
          # azure-client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          azure-tenant-id: ${{ vars.AZURE_TENANT_ID }}
          storage-account: ${{ vars.AZURE_STORAGE_ACCOUNT }}
          container: artifacts # ensure this exists
          key: ${{ needs.calculate.outputs.artifact_fingerprint_src_build }}
          path: ./build_output/
        
      - name: Test
        run: |
          echo "Pretending to test... $FINGERPRINT_COMMON_TEST"
          echo "build_common.txt:"
          cat ./common_build_output/build_common.txt
          echo "build.txt:"
          cat ./build_output/build.txt
          echo "===================="
          sleep 5
          echo "common tested for $FINGERPRINT_COMMON_TEST" > test.txt
          echo "Inputs:" >> test.txt
          cat  ./common_build_output/build_common.txt >> test.txt
          cat  ./build_output/build.txt >> test.txt
          echo "Pretending to test... done"

      # TODO - check out ncc or similar to avoid npm install step: https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action#commit-tag-and-push-your-action
      - name: Upload artifacts - npm install
        run: |
          cd .github/actions/upload_artifacts
          npm install
      - name: Azure login with federated credentials
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          allow-no-subscriptions: true
      - name: upload artifacts
        uses: ./.github/actions/upload_artifacts
        with:
          # azure-client-id: ${{ vars.AZURE_CLIENT_ID }}
          # azure-client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}
          azure-tenant-id: ${{ vars.AZURE_TENANT_ID }}
          storage-account: ${{ vars.AZURE_STORAGE_ACCOUNT }}
          container: artifacts # ensure this exists
          key: ${{ needs.calculate.outputs.artifact_fingerprint_test_test }}
          path: |
            test.txt

  final:
    runs-on: ubuntu-latest
    needs: [calculate, build-common, test-common, build, test]
    if: ${{ always() }}
    env:
      EXISTS_COMMON_BUILD: ${{ needs.calculate.outputs.artifact_exists_common_build }}
      EXISTS_COMMON_TEST: ${{ needs.calculate.outputs.artifact_exists_common_test }}
      FINGERPRINT_COMMON_BUILD: ${{ needs.calculate.outputs.artifact_fingerprint_common_build }}
      FINGERPRINT_COMMON_TEST: ${{ needs.calculate.outputs.artifact_fingerprint_common_test }}
      # FILTER_SRC: ${{ needs.calculate.outputs.filter_src }}
      # FILTER_TEST: ${{ needs.calculate.outputs.filter_test }}
      # FILTER_COMMON: ${{ needs.calculate.outputs.filter_common }}
      # FILTER_COMMON_SRC: ${{ needs.calculate.outputs.filter_common_src }}
      # FILTER_COMMON_TEST: ${{ needs.calculate.outputs.filter_common_test }}
      # HASH_SRC: ${{ needs.calculate.outputs.hash_src }}
      # HASH_TEST: ${{ needs.calculate.outputs.hash_test }}
      # HASH_COMMON: ${{ needs.calculate.outputs.hash_common }}
      # HASH_COMMON_SRC: ${{ needs.calculate.outputs.hash_common_src }}
      # HASH_COMMON_TEST: ${{ needs.calculate.outputs.hash_common_test }}
    steps:
      - name: Show vars
        run: |
          printenv | sort
